{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\sures\\\\OneDrive\\\\Desktop\\\\react practice\\\\react\\\\src\\\\contexts\\\\RecorderContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useCallback } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const RecorderContext = /*#__PURE__*/createContext();\nexport const RecorderProvider = ({\n  children\n}) => {\n  _s();\n  const [isMonitoring, setIsMonitoring] = useState(false);\n  const [isRecording, setIsRecording] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [timelineEvents, setTimelineEvents] = useState([]);\n  const [selectedEvent, setSelectedEvent] = useState(null);\n  const startMonitoring = useCallback(async () => {\n    try {\n      const response = await fetch('http://127.0.0.1:5000/start_monitoring', {\n        method: 'POST'\n      });\n      const data = await response.json();\n      if (data.success) {\n        setIsMonitoring(true);\n        startProgressRecording();\n      }\n    } catch (err) {\n      console.error('Start error:', err);\n    }\n  }, []);\n  const stopMonitoring = useCallback(async () => {\n    if (!isMonitoring) return;\n    try {\n      const response = await fetch('http://127.0.0.1:5000/stop_monitoring', {\n        method: 'POST'\n      });\n      const data = await response.json();\n      if (data.success) {\n        setIsMonitoring(false);\n        stopProgressRecording();\n        fetchAndDisplaySavedData();\n      }\n    } catch (err) {\n      console.error('Stop error:', err);\n    }\n  }, [isMonitoring]);\n  const startProgressRecording = useCallback(() => {\n    setProgress(0);\n    const progressInterval = setInterval(() => {\n      setProgress(prev => {\n        const newProgress = Math.min(prev + 0.5, 100);\n        return newProgress;\n      });\n    }, 100);\n    return () => clearInterval(progressInterval);\n  }, []);\n  const stopProgressRecording = useCallback(() => {\n    setProgress(0);\n  }, []);\n  const fetchAndDisplaySavedData = useCallback(async () => {\n    try {\n      const response = await fetch('http://127.0.0.1:5000/get_saved_data');\n      const data = await response.json();\n      if (data.success) {\n        setTimelineEvents(data.data);\n        // If there are events, select the first one by default\n        if (data.data.length > 0) {\n          setSelectedEvent({\n            event: data.data[0],\n            index: 0,\n            path: data.path\n          });\n        }\n      } else {\n        console.error('Error fetching saved data:', data.message);\n      }\n    } catch (error) {\n      console.error('Error fetching saved data:', error);\n    }\n  }, []);\n  const playAutomation = useCallback(async () => {\n    try {\n      const response = await fetch('http://127.0.0.1:5000/run_automation', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error('Failed to run automation');\n      }\n      const result = await response.json();\n      return result.success;\n    } catch (error) {\n      console.error('Error running automation:', error);\n      return false;\n    }\n  }, []);\n  const saveFlow = useCallback(async () => {\n    try {\n      // Get all events in their current order\n      const events = timelineEvents.map((event, index) => {\n        return {\n          id: event.id,\n          name: `Step ${index + 1}`,\n          type: getEventType(event)\n        };\n      });\n      const response = await fetch('http://127.0.0.1:5000/update_flow', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          events\n        })\n      });\n      const result = await response.json();\n      if (response.ok && result.success) {\n        fetchAndDisplaySavedData();\n        return true;\n      } else {\n        throw new Error(result.message || 'Server returned an error');\n      }\n    } catch (error) {\n      console.error('Error:', error);\n      return false;\n    }\n  }, [timelineEvents, fetchAndDisplaySavedData]);\n\n  // Helper function to determine event type\n  const getEventType = event => {\n    if (event.single_click) return 'Single Click';\n    if (event.double_click) return 'Double Click';\n    if (event.keyboard && event.keyboard.is_text) return 'Input Text';\n    if (event.keyboard && event.keyboard.is_special) return 'Key Pressed';\n    if (event.time_delay) return 'Delay Time';\n    return 'Unknown';\n  };\n\n  // Load saved data when component mounts\n  useEffect(() => {\n    fetchAndDisplaySavedData();\n  }, [fetchAndDisplaySavedData]);\n\n  // Poll for status when monitoring\n  useEffect(() => {\n    let statusInterval = null;\n    if (isMonitoring) {\n      statusInterval = setInterval(async () => {\n        try {\n          const res = await fetch('http://127.0.0.1:5000/status');\n          const data = await res.json();\n          if (data.monitoring !== isMonitoring) {\n            setIsMonitoring(data.monitoring);\n          }\n        } catch (err) {\n          console.error('Fetch status error:', err);\n        }\n      }, 1000);\n    }\n    return () => {\n      if (statusInterval) clearInterval(statusInterval);\n    };\n  }, [isMonitoring]);\n  return /*#__PURE__*/_jsxDEV(RecorderContext.Provider, {\n    value: {\n      isMonitoring,\n      isRecording,\n      progress,\n      timelineEvents,\n      selectedEvent,\n      setSelectedEvent,\n      startMonitoring,\n      stopMonitoring,\n      playAutomation,\n      saveFlow,\n      fetchAndDisplaySavedData\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 176,\n    columnNumber: 5\n  }, this);\n};\n_s(RecorderProvider, \"7lt2sX6hok4jV2pCYqkU9HyS4FE=\");\n_c = RecorderProvider;\nexport default RecorderProvider;\nvar _c;\n$RefreshReg$(_c, \"RecorderProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useCallback","jsxDEV","_jsxDEV","RecorderContext","RecorderProvider","children","_s","isMonitoring","setIsMonitoring","isRecording","setIsRecording","progress","setProgress","timelineEvents","setTimelineEvents","selectedEvent","setSelectedEvent","startMonitoring","response","fetch","method","data","json","success","startProgressRecording","err","console","error","stopMonitoring","stopProgressRecording","fetchAndDisplaySavedData","progressInterval","setInterval","prev","newProgress","Math","min","clearInterval","length","event","index","path","message","playAutomation","headers","ok","Error","result","saveFlow","events","map","id","name","type","getEventType","body","JSON","stringify","single_click","double_click","keyboard","is_text","is_special","time_delay","statusInterval","res","monitoring","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/sures/OneDrive/Desktop/react practice/react/src/contexts/RecorderContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useCallback } from 'react';\r\n\r\nexport const RecorderContext = createContext();\r\n\r\nexport const RecorderProvider = ({ children }) => {\r\n  const [isMonitoring, setIsMonitoring] = useState(false);\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [progress, setProgress] = useState(0);\r\n  const [timelineEvents, setTimelineEvents] = useState([]);\r\n  const [selectedEvent, setSelectedEvent] = useState(null);\r\n\r\n  const startMonitoring = useCallback(async () => {\r\n    try {\r\n      const response = await fetch('http://127.0.0.1:5000/start_monitoring', { \r\n        method: 'POST' \r\n      });\r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        setIsMonitoring(true);\r\n        startProgressRecording();\r\n      }\r\n    } catch (err) {\r\n      console.error('Start error:', err);\r\n    }\r\n  }, []);\r\n\r\n  const stopMonitoring = useCallback(async () => {\r\n    if (!isMonitoring) return;\r\n\r\n    try {\r\n      const response = await fetch('http://127.0.0.1:5000/stop_monitoring', {\r\n        method: 'POST'\r\n      });\r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        setIsMonitoring(false);\r\n        stopProgressRecording();\r\n        fetchAndDisplaySavedData();\r\n      }\r\n    } catch (err) {\r\n      console.error('Stop error:', err);\r\n    }\r\n  }, [isMonitoring]);\r\n\r\n  const startProgressRecording = useCallback(() => {\r\n    setProgress(0);\r\n    \r\n    const progressInterval = setInterval(() => {\r\n      setProgress(prev => {\r\n        const newProgress = Math.min(prev + 0.5, 100);\r\n        return newProgress;\r\n      });\r\n    }, 100);\r\n\r\n    return () => clearInterval(progressInterval);\r\n  }, []);\r\n\r\n  const stopProgressRecording = useCallback(() => {\r\n    setProgress(0);\r\n  }, []);\r\n\r\n  const fetchAndDisplaySavedData = useCallback(async () => {\r\n    try {\r\n      const response = await fetch('http://127.0.0.1:5000/get_saved_data');\r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        setTimelineEvents(data.data);\r\n        // If there are events, select the first one by default\r\n        if (data.data.length > 0) {\r\n          setSelectedEvent({ event: data.data[0], index: 0, path: data.path });\r\n        }\r\n      } else {\r\n        console.error('Error fetching saved data:', data.message);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error fetching saved data:', error);\r\n    }\r\n  }, []);\r\n\r\n  const playAutomation = useCallback(async () => {\r\n    try {\r\n      const response = await fetch('http://127.0.0.1:5000/run_automation', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error('Failed to run automation');\r\n      }\r\n\r\n      const result = await response.json();\r\n      return result.success;\r\n    } catch (error) {\r\n      console.error('Error running automation:', error);\r\n      return false;\r\n    }\r\n  }, []);\r\n\r\n  const saveFlow = useCallback(async () => {\r\n    try {\r\n      // Get all events in their current order\r\n      const events = timelineEvents.map((event, index) => {\r\n        return {\r\n          id: event.id,\r\n          name: `Step ${index + 1}`,\r\n          type: getEventType(event)\r\n        };\r\n      });\r\n\r\n      const response = await fetch('http://127.0.0.1:5000/update_flow', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({ events })\r\n      });\r\n\r\n      const result = await response.json();\r\n      if (response.ok && result.success) {\r\n        fetchAndDisplaySavedData();\r\n        return true;\r\n      } else {\r\n        throw new Error(result.message || 'Server returned an error');\r\n      }\r\n    } catch (error) {\r\n      console.error('Error:', error);\r\n      return false;\r\n    }\r\n  }, [timelineEvents, fetchAndDisplaySavedData]);\r\n\r\n  // Helper function to determine event type\r\n  const getEventType = (event) => {\r\n    if (event.single_click) return 'Single Click';\r\n    if (event.double_click) return 'Double Click';\r\n    if (event.keyboard && event.keyboard.is_text) return 'Input Text';\r\n    if (event.keyboard && event.keyboard.is_special) return 'Key Pressed';\r\n    if (event.time_delay) return 'Delay Time';\r\n    return 'Unknown';\r\n  };\r\n\r\n  // Load saved data when component mounts\r\n  useEffect(() => {\r\n    fetchAndDisplaySavedData();\r\n  }, [fetchAndDisplaySavedData]);\r\n\r\n  // Poll for status when monitoring\r\n  useEffect(() => {\r\n    let statusInterval = null;\r\n    \r\n    if (isMonitoring) {\r\n      statusInterval = setInterval(async () => {\r\n        try {\r\n          const res = await fetch('http://127.0.0.1:5000/status');\r\n          const data = await res.json();\r\n          \r\n          if (data.monitoring !== isMonitoring) {\r\n            setIsMonitoring(data.monitoring);\r\n          }\r\n        } catch (err) {\r\n          console.error('Fetch status error:', err);\r\n        }\r\n      }, 1000);\r\n    }\r\n    \r\n    return () => {\r\n      if (statusInterval) clearInterval(statusInterval);\r\n    };\r\n  }, [isMonitoring]);\r\n\r\n  return (\r\n    <RecorderContext.Provider value={{\r\n      isMonitoring,\r\n      isRecording,\r\n      progress,\r\n      timelineEvents,\r\n      selectedEvent,\r\n      setSelectedEvent,\r\n      startMonitoring,\r\n      stopMonitoring,\r\n      playAutomation,\r\n      saveFlow,\r\n      fetchAndDisplaySavedData\r\n    }}>\r\n      {children}\r\n    </RecorderContext.Provider>\r\n  );\r\n};\r\n\r\nexport default RecorderProvider; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}